
Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
    1    1                      ;**************************************************************************************
    2    2                      ;* Blank Project Main [includes LibV2.2]                                              *
    3    3                      ;**************************************************************************************
    4    4                      ;* Summary: Lab 4                                                                     *
    5    5                      ;*   -                                                                                *
    6    6                      ;*                                                                                    *
    7    7                      ;* Author: Julia Fay & Aiden Taylor                                                   *
    8    8                      ;*   Cal Poly University                                                              *
    9    9                      ;*   Fall 2023                                                                        *
   10   10                      ;*                                                                                    *
   11   11                      ;* Revision History:                                                                  *
   12   12                      ;*   -                                                                                *
   13   13                      ;*                                                                                    *
   14   14                      ;* ToDo:                                                                              *
   15   15                      ;*   -                                                                                *
   16   16                      ;**************************************************************************************
   17   17                      
   18   18                      ;/------------------------------------------------------------------------------------\
   19   19                      ;| Include all associated files                                                       |
   20   20                      ;\------------------------------------------------------------------------------------/
   21   21                      ; The following are external files to be included during assembly
   22   22                      
   23   23                      
   24   24                      ;/------------------------------------------------------------------------------------\
   25   25                      ;| External Definitions                                                               |
   26   26                      ;\------------------------------------------------------------------------------------/
   27   27                      ; All labels that are referenced by the linker need an external definition
   28   28                      
   29   29                                    XDEF  main
   30   30                      
   31   31                      ;/------------------------------------------------------------------------------------\
   32   32                      ;| External References                                                                |
   33   33                      ;\------------------------------------------------------------------------------------/
   34   34                      ; All labels from other files must have an external reference
   35   35                      
   36   36                                    XREF  ENABLE_MOTOR, DISABLE_MOTOR
   37   37                                    XREF  STARTUP_MOTOR, UPDATE_MOTOR, CURRENT_MOTOR
   38   38                                    XREF  STARTUP_PWM, STARTUP_ATD0, STARTUP_ATD1
   39   39                                    XREF  OUTDACA, OUTDACB
   40   40                                    XREF  STARTUP_ENCODER, READ_ENCODER
   41   41                                    XREF  INITLCD, SETADDR, GETADDR, CURSOR_ON, CURSOR_OFF, DISP_OFF
   42   42                                    XREF  OUTCHAR, OUTCHAR_AT, OUTSTRING, OUTSTRING_AT
   43   43                                    XREF  INITKEY, LKEY_FLG, GETCHAR
   44   44                                    XREF  LCDTEMPLATE, UPDATELCD_L1, UPDATELCD_L2
   45   45                                    XREF  LVREF_BUF, LVACT_BUF, LERR_BUF,LEFF_BUF, LKP_BUF, LKI_BUF
   46   46                                    XREF  Entry, ISR_KEYPAD
   47   47                                  
   48   48                      ;/------------------------------------------------------------------------------------\
   49   49                      ;| Assembler Equates                                                                  |
   50   50                      ;\------------------------------------------------------------------------------------/
   51   51                      ; Constant values can be equated here
   52   52                      
   53   53                      
   54   54                      
   55   55                      ;/------------------------------------------------------------------------------------\
   56   56                      ;| Variables in RAM                                                                   |
   57   57                      ;\------------------------------------------------------------------------------------/
   58   58                      ; The following variables are located in unpaged ram
   59   59                      
   60   60                      DEFAULT_RAM:  SECTION
   61   61                      
   62   62                      ;params for t1 interrupt 
   63   63          0000 0001   Chan0 EQU $01
   64   64          0000 0040   TIOS  EQU $0040

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
   65   65          0000 0049   TCTL2 EQU $0049
   66   66          0000 004E   TFLG1 EQU $004E
   67   67          0000 004C   TMSK1 EQU $004C
   68   68          0000 0046   TSCR  EQU $0046
   69   69          0000 0044   TCNTH EQU $0044
   70   70          0000 0050   TC0   EQU $0050
   71   71   000000             INTERVAL DS.W 1
   72   72                      
   73   73                      ;params for t2 
   74   74                      
   75   75   000002             SELECT_FLG DS.B 1 
   76   76   000003             COUNT DS.B 1 
   77   77   000004             MM_ERR  DS.B 1
   78   78   000005             NINT DS.W 1
   79   79   000007             WAVE_NUM DS.B 1 
   80   80                      
   81   81                      ;params for t3 
   82   82   000008             KEY_FLG DS.B 1
   83   83   000009             KEY_BUFF DS.B 1
   84   84                      
   85   85                      ;params for t4
   86   86   00000A             MSG_NUM DS.B 1
   87   87                      
   88   88                      ;params for t5
   89   89   00000B             RUN DS.B 1
   90   90   00000C             CINT DS.W 1 
   91   91   00000E             NEWBTI DS.B 1  
   92   92   00000F             WAVEPTR DS.W 1  
   93   93   000011             CSEG DS.B 1 
   94   94   000012             LSEG DS.B 1  
   95   95   000013             SEGPTR DS.W 1  
   96   96   000015             SEGINC DS.W 1  
   97   97   000017             VALUE DS.W 1 
   98   98   000019             DWAVE DS.B 1 
   99   99   00001A             DPRMPT DS.B 1
  100  100   00001B             NINTOK DS.B 1 
  101  101                      
  102  102                      ;state vars
  103  103   00001C             t1state DS.B 1
  104  104   00001D             t2state DS.B 1
  105  105   00001E             t3state DS.B 1
  106  106   00001F             t4state DS.B 1
  107  107   000020             t5state DS.B 1
  108  108   000021             t6state DS.B 1
  109  109   000022             t7state DS.B 1
  110  110   000023             t8state DS.B 1
  111  111                      
  112  112                      ;subroutines ---------
  113  113                      
  114  114                      ;convert
  115  115   000024             RESULT DS.W 1 
  116  116   000026             BUFFER DS.B 3
  117  117   000029             TMP DS.B 1
  118  118   00002A             ERR DS.B 1 
  119  119                      
  120  120                      ;input
  121  121   00002B             INPUT DS.B 1
  122  122   00002C             DPTR DS.W 1
  123  123   00002E             FIRSTCH DS.B 1
  124  124                      
  125  125                      ;display
  126  126   00002F             COUNT_ERR DS.W 1
  127  127   000031             TICKS_ERR DS.W 1
  128  128                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  129  129                      
  130  130                      ;/------------------------------------------------------------------------------------\
  131  131                      ;|  Main Program Code                                                                 |
  132  132                      ;\------------------------------------------------------------------------------------/
  133  133                      ; Your code goes here
  134  134                      
  135  135                      MyCode:       SECTION
  136  136                      main:   
  137  137                        
  138  138   000000 79xx xx             clr t1state ; initialize all tasks to state 0
  139  139   000003 79xx xx             clr t2state
  140  140   000006 79xx xx             clr t3state
  141  141   000009 79xx xx             clr t4state
  142  142   00000C 79xx xx             clr t5state 
  143  143                              
  144  144                      top:
  145  145                             
  146  146   00000F 16xx xx             jsr TASK_1  ; execute tasks endlessly
  147  147   000012 16xx xx             jsr TASK_2
  148  148   000015 16xx xx             jsr TASK_3
  149  149   000018 16xx xx             jsr TASK_4
  150  150                              ;bgnd
  151  151   00001B 16xx xx             jsr TASK_5
  152  152                              ;movb #$01, NEWBTI
  153  153   00001E 20EF                bra top       
  154  154                               
  155  155   000020 20FE        spin:   bra   spin                     ; endless horizontal loop
  156  156                      
  157  157                      
  158  158                      ;-------------TASK_1 TC0 SETUP ---------------------------------------------------------
  159  159                      
  160  160                      TASK_1:
  161  161                      
  162  162   000022 B6xx xx             ldaa t1state ;get state
  163  163   000025 2703                beq t1s0
  164  164   000027 43                  deca
  165  165   000028 2723                beq t1s1
  166  166                      
  167  167                      t1s0: 
  168  168                      
  169  169                      ;Step 1: Pre-initialization
  170  170                      		   
  171  171   00002A 1803 03E8   		   movw #1000, INTERVAL ; Determine the number of bus clock counts that corresponds to 0.1 msec.
             00002E xxxx       
  172  172                      		   
  173  173                      ;Step 2: Timer Initialization
  174  174                      		   
  175  175   000030 4C40 01     		   bset TIOS, Chan0     ; Set timer channel 0 for output compare
  176  176   000033 4C49 01     		   bset TCTL2,Chan0     ; Set timer channel 0 to toggle its output pin
  177  177   000036 4C4E 01     		   bset TFLG1, Chan0    ; Clear timer channel flag by writing a 1 to it 
  178  178   000039 10EF        		   cli                  ; Clear I bit 
  179  179   00003B 4C4C 01     		   bset TMSK1, Chan0    ; enable maskable interrupts 
  180  180                      		   
  181  181                      
  182  182   00003E 4C46 A0     		   bset TSCR, %10100000 ; enable timer channel output compare intuerrupts 
  183  183                      		                        ; sets TEN = 1  (enable timer bit)
  184  184                      		                        ; sets TSBCK = 1 (timer stop in background mode) 
  185  185                      
  186  186                      ;Step 3: Generating the first interrupt		   
  187  187                      		  
  188  188   000041 DC44        		   ldd TCNTH            ; read current timer count 
  189  189   000043 F3xx xx     		   addd INTERVAL        ; add interval to count 
  190  190   000046 5C50        		   std TC0              ; load result into TC0
  191  191                      		   

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  192  192   000048 180B 01xx   		   movb #$01, t1state   ;set t1state to 1 
             00004C xx         
  193  193                      
  194  194                      t1s1:  
  195  195                      
  196  196   00004D 3D           rts 
  197  197                      
  198  198                      
  199  199                      
  200  200                       ;-------------TASK_2 MASTERMIND ---------------------------------------------------------
  201  201                      
  202  202                       TASK_2: 
  203  203                       
  204  204   00004E B6xx xx             ldaa t2state ;get state
  205  205   000051 271D                beq t2s0
  206  206   000053 43                  deca
  207  207   000054 2732                beq t2s1
  208  208   000056 43                  deca
  209  209   000057 1827 0085           lbeq t2s2
  210  210   00005B 43                  deca  
  211  211   00005C 1827 00B7           lbeq t2s3
  212  212   000060 43                  deca 
  213  213   000061 1827 0103           lbeq t2s4 
  214  214   000065 43                  deca 
  215  215   000066 1827 010F           lbeq t2s5 
  216  216   00006A 43                  deca 
  217  217   00006B 1827 0131           lbeq t2s6
  218  218   00006F 3D                  rts
  219  219                      
  220  220                      ;__________________________________________________________________________________
  221  221                      
  222  222                      t2s0: ; init TASK_2
  223  223                      
  224  224                      ;clear all of the flags and relevant ITCVs
  225  225                       
  226  226   000070 79xx xx             clr SELECT_FLG 
  227  227   000073 79xx xx             clr KEY_FLG 
  228  228   000076 79xx xx             clr COUNT
  229  229   000079 79xx xx             clr WAVE_NUM
  230  230   00007C 16xx xx             jsr clearbuffer                             ;clear buffer
  231  231   00007F 180B 01xx           movb #$01, t2state                          ;set next state
             000083 xx         
  232  232   000084 1820 0141           lbra exit2                                  ;exit
  233  233                              
  234  234                       ;__________________________________________________________________________________
  235  235                             
  236  236                      t2s1: ;hub        
  237  237                              
  238  238   000088 F7xx xx             tst KEY_FLG                                 ;first test if there is a key to be checked
  239  239   00008B 1827 013A           lbeq exit2                                  ;if there is no key exit
  240  240                              
  241  241                       ;check if 1-4 have already been pressed for the first time 
  242  242                       
  243  243   00008F B6xx xx             ldaa KEY_BUFF                               ;load accumulator A with the current char
  244  244   000092 F7xx xx             tst SELECT_FLG                              ;test if have already selected a wave 
  245  245   000095 2614                bne skip_select                             ;skip setting the t1 state if already pressed once 
  246  246                       
  247  247                       ;if 1-4 has not been pushed yet, check if its being pushed for the first time 
  248  248                       
  249  249                       ;load accumulator d with the current ascii hex digit to make sure all arithmetic is correct 
  250  250                             
  251  251   000097 36                  psha                                        ;push whats in a to the stack 
  252  252   000098 33                  pulb                                        ;pul what was in a into b 
  253  253   000099 8600                ldaa #$00                                   ;put zeros in a to make it a positive num

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  254  254                              
  255  255   00009B 8C00 34             cpd #$34                                    ;check if what in A is 1-4 
  256  256   00009E 2E0B                bgt skip_select                             ;if its not 1-4, disregard the input  
  257  257   0000A0 37                  pshb                                        ;restore the stack 
  258  258   0000A1 32                  pula  
  259  259   0000A2 180B 05xx           movb #$05 , t2state                         ;set the state to select  
             0000A6 xx         
  260  260   0000A7 1820 011E           lbra exit2               
  261  261                      
  262  262                      skip_select:
  263  263                       
  264  264                      ;check if its a BS 
  265  265                             
  266  266   0000AB 8108                cmpa #$08                                   ;compare whats in A to BS 
  267  267   0000AD 2609                bne skipBS                                  ;if its not BS, skip settting the state 
  268  268   0000AF 180B 04xx           movb #$04 , t2state                         ;set the state to the appropriate number 
             0000B3 xx         
  269  269   0000B4 1820 0111           lbra exit2                                  ;exit
  270  270                      
  271  271                      skipBS: 
  272  272                      
  273  273                      ;check if its a ENT  
  274  274                      
  275  275   0000B8 810A                cmpa #$0A                                   ;compare whats in A to ENT 
  276  276   0000BA 2609                bne skipENT                                 ;if its not BS, skip settting the state 
  277  277   0000BC 180B 03xx           movb #$03 , t2state                         ;set the state to the appropriate number 
             0000C0 xx         
  278  278   0000C1 1820 0104           lbra exit2                                  ;exit
  279  279                              
  280  280                      skipENT:
  281  281                      
  282  282                      ;check if its a digit
  283  283                       
  284  284   0000C5 36                  psha                                        ;push whats in a to the stack 
  285  285   0000C6 33                  pulb                                        ;pul what was in a into b 
  286  286   0000C7 8600                ldaa #$00                                   ;put zeros in a to make it a positive num
  287  287                              
  288  288   0000C9 8C00 39             cpd #$39                                    ;check if what in A is a number 
  289  289   0000CC 2E0B                bgt skipDIGIT                               ;if its not a number, disregard the input
  290  290   0000CE 37                  pshb                                        ;restore the stack 
  291  291   0000CF 32                  pula
  292  292                               
  293  293   0000D0 180B 02xx           movb #$02 , t2state                         ;set the state to digit handler 
             0000D4 xx         
  294  294   0000D5 1820 00F0           lbra exit2                                  ;exit
  295  295                      
  296  296                      skipDIGIT: 
  297  297                      
  298  298   0000D9 79xx xx             clr KEY_FLG
  299  299   0000DC 1820 00E9           lbra exit2                                  ;exit
  300  300                        
  301  301                      ;__________________________________________________________________________________
  302  302                              
  303  303                      t2s2: ;Digit Handler 
  304  304                      
  305  305                      ;checks if we should proceed with the digit handler state 
  306  306                      
  307  307   0000E0 F6xx xx             ldab COUNT                                  ;load b with count 
  308  308   0000E3 C103                cmpb #$03                                   ;check if count is 3
  309  309   0000E5 2705                beq toomany                                 ;if count is 3 stop taking inputs and leave
  310  310   0000E7 F7xx xx             tst SELECT_FLG                              ;test SELECT_FLG 
  311  311   0000EA 260C                bne skip_e                                  ;if not equal to 0, skip exiting 
  312  312                      
  313  313                      toomany:        

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  314  314                              
  315  315   0000EC 79xx xx             clr KEY_FLG                                 ;clear keyflag 
  316  316   0000EF 180B 01xx           movb #$01 , t2state                         ;set the state back to 1
             0000F3 xx         
  317  317   0000F4 1820 00D1           lbra exit2                                  ;exit  
  318  318                                                      
  319  319                      skip_e:
  320  320                      
  321  321                      ;now proceed with the digit handler
  322  322                         
  323  323   0000F8 CDxx xx             ldy #BUFFER                                 ;load index register y with buffer 
  324  324   0000FB B6xx xx             ldaa COUNT                                  ;load A with the current value of COUNT 
  325  325   0000FE F6xx xx             ldab KEY_BUFF                               ;load b with KEY_BUFF 
  326  326   000101 6BEC                stab a,y                                    ;store the contents of b at the position of COUNT in BUFFER
  327  327                             
  328  328   000103 72xx xx             inc COUNT                                   ;increment count 
  329  329   000106 79xx xx             clr KEY_FLG                                 ;set key flag to 0 to acknowledge KEYPAD
  330  330   000109 180B 01xx           movb #$01 , t2state                         ;set the state back to 1  
             00010D xx         
  331  331   00010E 180B 0Bxx           movb #$0B, MSG_NUM                          ;set state in display task to echo the char
             000112 xx         
  332  332   000113 1820 00B2           lbra exit2                                  ;exit 
  333  333                      
  334  334                      ;__________________________________________________________________________________
  335  335                              
  336  336                      t2s3: ;ENTER 
  337  337                      
  338  338                               
  339  339                      ;before jsr to conversion, check if any digits have been entered into buffer      
  340  340                             
  341  341   000117 16xx xx            jsr clrcurs                                 ;turn off the cursor when enter is hit   
  342  342   00011A F7xx xx            tst COUNT                                   ;test the current value of count 
  343  343   00011D 2604               bne skip_NO_DIGITS                          ;if the count is not zero, branch 
  344  344   00011F 8603               ldaa #$03                                   ;if the count is zero, put an error code into A 
  345  345   000121 200C               bra check_error                             ;branch to the set error state below 
  346  346                      
  347  347                      
  348  348                       skip_NO_DIGITS: 
  349  349                      
  350  350                      ;send to conversion to get a BCD form of the input 
  351  351                          
  352  352   000123 16xx xx            jsr conversion                              ;convert the contents of buffer to binary 
  353  353   000126 7Exx xx            stx NINT                                    ;store the result of conversion in NINT 
  354  354   000129 79xx xx            clr COUNT                                   ;set count back to zero 
  355  355   00012C 79xx xx            clr BUFFER                                  ;clear the contents of the BUFFER
  356  356                             
  357  357                                  
  358  358                      check_error: 
  359  359                             
  360  360                      ;automatically set the state back to 1 for all cases  
  361  361                      
  362  362   00012F 180B 01xx          movb #$01, t2state                          ;set the state back to 1 
             000133 xx         
  363  363                             
  364  364                      ;check for error and set variables and state accordingly so that user has to start over 
  365  365                      
  366  366   000134 8100               cmpa #$00                                   ;check whats in A 
  367  367   000136 2718               beq skipERROR                               ;check if an error was generated from conversion
  368  368   000138 180B 06xx          movb #$06, t2state                          ;if there is an error code set the state to the 
             00013C xx         
  369  369                                                                         ;error state
  370  370   00013D 7Axx xx            staa MM_ERR                                 ;store the error code of accumulator A into a variable 
  371  371                                                                         ;so it is not affected by other code before it gets to 
  372  372                                                                         ;the error state 

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  373  373   000140 79xx xx            clr NINT                                    ;clear NINT 
  374  374   000143 79xx xx            clr KEY_FLG                                 ;clear key flag
  375  375   000146 16xx xx            jsr clearbuffer
  376  376   000149 16xx xx            jsr CURSOR_OFF   
  377  377   00014C 1820 0079          lbra exit2                                   
  378  378                      
  379  379                      skipERROR: 
  380  380                      
  381  381                      ;if there are no errors, clear the select and key flags and buffer and exit     
  382  382                            
  383  383   000150 16xx xx           jsr clearbuffer                               ;set run to be true if there are no errors 
  384  384   000153 16xx xx           jsr CURSOR_OFF 
  385  385   000156 79xx xx           clr KEY_FLG 
  386  386   000159 79xx xx           clr SELECT_FLG  
  387  387   00015C 79xx xx           clr DWAVE 
  388  388   00015F 180B 01xx         movb #$01, NINTOK 
             000163 xx         
  389  389   000164 1820 0061         lbra exit2                                    ;exit
  390  390                      
  391  391                      ;________________________________________________________________________________________
  392  392                      
  393  393                      t2s4: ;BS
  394  394                       
  395  395   000168 180B 03xx          movb #$03 , t4state                         ;set the state in task 4 to the BS state   
             00016C xx         
  396  396   00016D 180B 01xx          movb #$01 , t2state                         ;set the state back to 1
             000171 xx         
  397  397   000172 79xx xx            clr KEY_FLG 
  398  398   000175 1820 0050          lbra exit2                                   ;exit
  399  399                      
  400  400                      ;________________________________________________________________________________________
  401  401                      
  402  402                      t2s5: ;SELECT state 
  403  403                       
  404  404                               
  405  405   000179 180B 01xx          movb #$01, SELECT_FLG                       ;set the SELECT_FLG to be true
             00017D xx         
  406  406   00017E 180B 01xx          movb #$01, DWAVE                                   ;clear the display wave flag 
             000182 xx         
  407  407   000183 79xx xx            clr NINTOK                                  ;clear NINTOK 
  408  408   000186 79xx xx            clr RUN                                     ;clear run 
  409  409   000189 B6xx xx            ldaa KEY_BUFF                               ;load a with whats in KEY_BUFF 
  410  410   00018C 8030               suba #$30	  	                             ;subtract $30 to get the decimal value of the ascii code
  411  411   00018E 7Axx xx            staa WAVE_NUM                               ;store the wave number 
  412  412                             
  413  413                            ;set the display state in task 4 
  414  414                            
  415  415   000191 8B03               adda #$03               ;add 3 to get the corresponding task 4 state
  416  416   000193 7Axx xx            staa t4state            ;store message number in state 
  417  417                             
  418  418                            ;set the state back to one, clear key flag, and exit 
  419  419                            
  420  420   000196 180B 01xx          movb #$01 , t2state                         ;set the state back to 1 
             00019A xx         
  421  421   00019B 79xx xx            clr KEY_FLG                                 ;clear the key flag  
  422  422   00019E 2029               bra exit2                                   ;exit
  423  423                             
  424  424                           
  425  425                      ;________________________________________________________________________________________
  426  426                      
  427  427                      t2s6: ;Error state 
  428  428                      
  429  429                      
  430  430                      ;checks the error code in accumulator A to set the appropiate fixed 

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  431  431                      ;message state to be displayed through task 4 
  432  432                      
  433  433                      
  434  434                      ;now check the error number and set the message number for task 4 
  435  435                       
  436  436   0001A0 B6xx xx            ldaa MM_ERR                                  ;put the error number back into accumulator a 
  437  437   0001A3 8101               cmpa #01                                     ;check if the error code is mag to large 
  438  438   0001A5 2605               bne skip_toolarge                            ;skip setting the message num
  439  439   0001A7 180B 08xx          movb #$08, MSG_NUM                           ;set the appropiate message num 
             0001AB xx         
  440  440                      
  441  441                      skip_toolarge: 
  442  442                      
  443  443   0001AC 8102               cmpa #02                                     ;check if the error code is zero magnitude 
  444  444   0001AE 2605               bne skip_zeromag                             ;skip setting the message num
  445  445   0001B0 180B 09xx          movb #$09, MSG_NUM                           ;set the appropiate message num 
             0001B4 xx         
  446  446                      
  447  447                      skip_zeromag: 
  448  448                      
  449  449   0001B5 8103               cmpa #03                                     ;check if the error code is zero digits
  450  450   0001B7 2605               bne skip_zerodigits                          ;skip setting the message num
  451  451   0001B9 180B 0Axx          movb #$0A, MSG_NUM                           ;set the appropiate message num    
             0001BD xx         
  452  452                      
  453  453                      skip_zerodigits: 
  454  454                         
  455  455   0001BE 180B 01xx          movb #$01 , t2state                         ;set the state back to 1
             0001C2 xx         
  456  456   0001C3 16xx xx            jsr clearbuffer
  457  457   0001C6 79xx xx            clr KEY_FLG
  458  458                             
  459  459                             
  460  460                      ;might be missing the clearing of some variables here 
  461  461                      
  462  462                      exit2: 
  463  463                       
  464  464   0001C9 3D                 rts                                         
  465  465                      
  466  466                       ;-------------TASK_3 KEYPAD ---------------------------------------------------------
  467  467                      
  468  468                       TASK_3:
  469  469                       
  470  470   0001CA B6xx xx             ldaa t3state ;get state
  471  471   0001CD 2707                beq t3s0
  472  472   0001CF 43                  deca
  473  473   0001D0 2710                beq t3s1
  474  474   0001D2 43                  deca
  475  475   0001D3 2724                beq t3s2
  476  476   0001D5 3D                  rts
  477  477                      
  478  478                      t3s0:   ;init
  479  479                              
  480  480   0001D6 16xx xx             jsr INITKEY       ;initialize keypad
  481  481   0001D9 79xx xx             clr KEY_BUFF
  482  482   0001DC 180B 01xx           movb #$01, t3state
             0001E0 xx         
  483  483   0001E1 3D                  rts
  484  484                              
  485  485                      t3s1:   ;Wait for Key   
  486  486                         
  487  487   0001E2 F7xx xx             tst LKEY_FLG             ;check if there is a digit in the buffer 
  488  488   0001E5 271C                beq exit3                ;if no key then exit 
  489  489   0001E7 16xx xx             jsr GETCHAR              ;get the character 

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  490  490   0001EA 7Bxx xx             stab KEY_BUFF            ;stores the input char into key buffer
  491  491   0001ED 180B 01xx           movb #$01, KEY_FLG       ;set ITCV keyflag to notifiy MM of key input
             0001F1 xx         
  492  492   0001F2 180B 02xx           movb #$02, t3state       ;set the state to state 2 
             0001F6 xx         
  493  493   0001F7 20D0                bra exit2                ;exit
  494  494                              
  495  495                      t3s2:   ;Wait for Acknowledgement 
  496  496                      
  497  497   0001F9 F7xx xx             tst KEY_FLG              ;test the ITCV KEY_FLG 
  498  498   0001FC 2605                bne exit3                ;if it is still 1 then do not change state 
  499  499   0001FE 180B 01xx           movb #$01, t3state       ;if it is 0, set state back to 1         
             000202 xx         
  500  500                      
  501  501   000203 3D          exit3: rts                       ;exit 
  502  502                              
  503  503                              
  504  504                              
  505  505                      ;-------------TASK_4 DISPLAY ---------------------------------------------------------
  506  506                      
  507  507                      
  508  508                      TASK_4:
  509  509                      
  510  510   000204 B6xx xx             ldaa t4state
  511  511   000207 2736                beq t4s0
  512  512   000209 43                  deca
  513  513   00020A 274C                beq t4s1
  514  514   00020C 43                  deca
  515  515   00020D 1827 0058           lbeq t4s2
  516  516   000211 43                  deca
  517  517   000212 1827 0063           lbeq t4s3
  518  518   000216 43                  deca
  519  519   000217 1827 006F           lbeq t4s4
  520  520   00021B 43                  deca
  521  521   00021C 1827 0078           lbeq t4s5
  522  522   000220 43                  deca
  523  523   000221 1827 0081           lbeq t4s6
  524  524   000225 43                  deca
  525  525   000226 1827 008A           lbeq t4s7
  526  526   00022A 43                  deca
  527  527   00022B 1827 0093           lbeq t4s8
  528  528   00022F 43                  deca
  529  529   000230 1827 009C           lbeq t4s9
  530  530   000234 43                  deca
  531  531   000235 1827 00A5           lbeq t4s10
  532  532   000239 43                  deca
  533  533   00023A 1827 00AE           lbeq t4s11
  534  534   00023E 3D                  rts
  535  535                      ;________________________________________________________________________________________
  536  536                      
  537  537                      t4s0:   ;init    
  538  538                              
  539  539   00023F 16xx xx             jsr INITLCD             ;initialize LCD
  540  540   000242 180B 01xx           movb #$01, FIRSTCH      ;set first char to be true 
             000246 xx         
  541  541   000247 8600                ldaa #$00               ;set LCD position to 0
  542  542   000249 16xx xx             jsr SETADDR             ;set the address 
  543  543   00024C 1803 5000           movw #$5000, TICKS_ERR  ;set the ticks error to be ___
             000250 xxxx       
  544  544   000252 180B 02xx           movb #$02, t4state      ;automatically go to state 2 to display the initial message   
             000256 xx         
  545  545   000257 3D                  rts                     ;exit 
  546  546                      
  547  547                      ;________________________________________________________________________________________

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  548  548                      t4s1:  ;hub
  549  549                                   
  550  550   000258 180B 01xx           movb #$01, FIRSTCH      ;set first char to be true  
             00025C xx         
  551  551   00025D F6xx xx             ldab MSG_NUM            ;load message number into b 
  552  552   000260 7Bxx xx             stab t4state            ;store message number in state 
  553  553   000263 180B 01xx           movb #$01, MSG_NUM      ;reset message num       
             000267 xx         
  554  554   000268 3D                  rts                     ;exit 
  555  555                       
  556  556                      ;________________________________________________________________________________________
  557  557                      t4s2:  ;set screen 
  558  558                      
  559  559   000269 CExx xx             ldx #TOP
  560  560   00026C 8600                ldaa #$00               ;set LCD position to 0
  561  561   00026E F7xx xx             tst FIRSTCH 
  562  562   000271 1826 008E           lbne char1
  563  563   000275 16xx xx             jsr PUTCHAR           
  564  564   000278 3D                  rts 
  565  565                        
  566  566                      ;________________________________________________________________________________________
  567  567                      t4s3:   ;backspace 
  568  568                      
  569  569   000279 B6xx xx             ldaa COUNT 
  570  570   00027C 8B5B                adda #$5B
  571  571   00027E 16xx xx             jsr SETADDR 
  572  572   000281 16xx xx             jsr backspace           ;go to backspace subroutine 
  573  573   000284 180B 01xx           movb #$01, t4state      ;reset to state 1 
             000288 xx         
  574  574   000289 3D                  rts                     ;exit      
  575  575                              
  576  576                      ;________________________________________________________________________________________
  577  577                      t4s4:   ;saw message (wave #1)
  578  578                      
  579  579   00028A CExx xx             ldx #SAWMSG
  580  580   00028D 8640                ldaa #$40               ;set LCD position to 40
  581  581   00028F F7xx xx             tst FIRSTCH 
  582  582   000292 266F                bne char1
  583  583   000294 16xx xx             jsr PUTCHAR
  584  584   000297 3D                  rts  
  585  585                                
  586  586                       ;________________________________________________________________________________________
  587  587                      t4s5:   ;7-seg message  (wave #2)
  588  588                      
  589  589   000298 CExx xx             ldx #SEG7MSG
  590  590   00029B 8640                ldaa #$40               ;set LCD position to 40
  591  591   00029D F7xx xx             tst FIRSTCH 
  592  592   0002A0 2661                bne char1
  593  593   0002A2 16xx xx             jsr PUTCHAR
  594  594   0002A5 3D                  rts  
  595  595                                
  596  596                      ;________________________________________________________________________________________
  597  597                      t4s6:   ;square message  (wawve #3)
  598  598                      
  599  599   0002A6 CExx xx             ldx #SQUAREMSG 
  600  600   0002A9 8640                ldaa #$40               ;set LCD position to 40
  601  601   0002AB F7xx xx             tst FIRSTCH 
  602  602   0002AE 2653                bne char1
  603  603   0002B0 16xx xx             jsr PUTCHAR
  604  604   0002B3 3D                  rts  
  605  605                               
  606  606                      ;________________________________________________________________________________________
  607  607                      t4s7:   ;15-seg message  (wave #4) 
  608  608                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  609  609   0002B4 CExx xx             ldx #SEG15MSG 
  610  610   0002B7 8640                ldaa #$40               ;set LCD position to 40
  611  611   0002B9 F7xx xx             tst FIRSTCH 
  612  612   0002BC 2645                bne char1
  613  613   0002BE 16xx xx             jsr PUTCHAR
  614  614   0002C1 3D                  rts 
  615  615                      ;________________________________________________________________________________________
  616  616                      t4s8:   ;too large error message
  617  617                      
  618  618                       ;can have only three error message states by storing the previous state in a variable and
  619  619                       ;and setting the task 4 state back to that state 
  620  620                       
  621  621   0002C2 CExx xx             ldx #E1
  622  622   0002C5 8655                ldaa #$55               ;set LCD position to 61
  623  623   0002C7 F7xx xx             tst FIRSTCH 
  624  624   0002CA 2637                bne char1
  625  625   0002CC 16xx xx             jsr PUTCHAR
  626  626   0002CF 3D                  rts 
  627  627                      
  628  628                      ;________________________________________________________________________________________
  629  629                      t4s9:   ;invalid magnitude message
  630  630                              
  631  631   0002D0 CExx xx             ldx #E2
  632  632   0002D3 8655                ldaa #$55               ;set LCD position to 61
  633  633   0002D5 F7xx xx             tst FIRSTCH                       
  634  634   0002D8 2629                bne char1
  635  635   0002DA 16xx xx             jsr PUTCHAR
  636  636   0002DD 3D                  rts 
  637  637                      
  638  638                      ;________________________________________________________________________________________
  639  639                      t4s10:  ;no digits entered message
  640  640                      
  641  641   0002DE CExx xx             ldx #E3
  642  642   0002E1 8655                ldaa #$55               ;set LCD position to 61
  643  643   0002E3 F7xx xx             tst FIRSTCH 
  644  644   0002E6 261B                bne char1
  645  645   0002E8 16xx xx             jsr PUTCHAR
  646  646   0002EB 3D                  rts 
  647  647                      ;________________________________________________________________________________________
  648  648                      t4s11:   ;echo 
  649  649                              
  650  650   0002EC B6xx xx             ldaa COUNT 
  651  651   0002EF 8B5A                adda #$5A
  652  652   0002F1 16xx xx             jsr SETADDR 
  653  653   0002F4 16xx xx             jsr CURSOR_ON 
  654  654                              
  655  655   0002F7 F6xx xx             ldab KEY_BUFF           ;load accumulator b with whats in KEY_BUFF 
  656  656   0002FA 16xx xx             jsr OUTCHAR             ;display the inputted digit 
  657  657   0002FD 180B 01xx           movb #$01, t4state      ;reset to state 1
             000301 xx         
  658  658                              
  659  659   000302 3D                  rts
  660  660                      
  661  661                      char1: 
  662  662                        
  663  663   000303 16xx xx             jsr PUTCHAR1      
  664  664                              
  665  665                      ;-------------TASK_5 FUNCTION GENERATOR -----------------------------------------------
  666  666                              
  667  667                      
  668  668                       TASK_5:
  669  669                      
  670  670   000306 B6xx xx             ldaa t5state
  671  671   000309 2711                beq t5s0

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  672  672   00030B 43                  deca
  673  673   00030C 2737                beq t5s1
  674  674   00030E 43                  deca
  675  675   00030F 2778                beq t5s2
  676  676   000311 43                  deca
  677  677   000312 1827 009E           lbeq t5s3
  678  678   000316 43                  deca
  679  679   000317 1827 00A9           lbeq t5s4
  680  680   00031B 3D                  rts
  681  681                              
  682  682                      ;________________________________________________________________________________________
  683  683                      
  684  684                      t5s0:   ;init    
  685  685                              
  686  686   00031C 79xx xx             clr RUN 
  687  687   00031F 79xx xx             clr CSEG
  688  688   000322 79xx xx             clr LSEG 
  689  689   000325 1879 xxxx           clrw SEGINC 
  690  690   000329 1879 xxxx           clrw SEGPTR
  691  691   00032D 1879 xxxx           clrw NINT
  692  692   000331 1879 xxxx           clrw CINT  
  693  693   000335 79xx xx             clr NINTOK 
  694  694   000338 1879 xxxx           clrw WAVEPTR 
  695  695   00033C 1879 xxxx           clrw VALUE  
  696  696   000340 180B 01xx           movb #$01, t5state                   
             000344 xx         
  697  697                      
  698  698                      ;________________________________________________________________________________________
  699  699                      
  700  700                      t5s1:  ;wait for wave 
  701  701                                   
  702  702                      ;set the corrrect wave address  
  703  703                             
  704  704                             ;bgnd
  705  705   000345 B6xx xx            ldaa WAVE_NUM 
  706  706   000348 1827 00C1          lbeq exit5 
  707  707   00034C 43                 deca 
  708  708   00034D 270A               beq t5w1
  709  709   00034F 43                 deca 
  710  710   000350 2713               beq t5w2 
  711  711   000352 43                 deca 
  712  712   000353 271C               beq t5w3 
  713  713   000355 43                 deca
  714  714   000356 2725               beq t5w4 
  715  715   000358 3D                 rts
  716  716                             
  717  717                      t5w1:
  718  718   000359 CExx xx            ldx #SAWTOOTH
  719  719   00035C 7Exx xx            stx WAVEPTR
  720  720   00035F 180B 02xx          movb #$02, t5state
             000363 xx         
  721  721   000364 3D                 rts  
  722  722                      
  723  723                      t5w2: 
  724  724   000365 CExx xx            ldx #SINE_7
  725  725   000368 7Exx xx            stx WAVEPTR
  726  726   00036B 180B 02xx          movb #$02, t5state
             00036F xx         
  727  727   000370 3D                 rts 
  728  728                        
  729  729                            
  730  730                      t5w3:       
  731  731   000371 CExx xx            ldx #SQUARE
  732  732   000374 7Exx xx            stx WAVEPTR

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  733  733   000377 180B 02xx          movb #$02, t5state
             00037B xx         
  734  734   00037C 3D                 rts 
  735  735                      
  736  736                      t5w4: 
  737  737                      
  738  738   00037D CExx xx            ldx #SINE_15
  739  739   000380 7Exx xx            stx WAVEPTR
  740  740   000383 180B 02xx          movb #$02, t5state
             000387 xx         
  741  741   000388 3D                 rts  
  742  742                            
  743  743                                              
  744  744                       
  745  745                      ;________________________________________________________________________________________
  746  746                      
  747  747                      t5s2:  ;new wave 
  748  748                      
  749  749                      
  750  750   000389 F7xx xx             tst DWAVE ; wait for display of wave message
  751  751                              ;bgnd
  752  752   00038C 2625                bne t5s2a
  753  753   00038E FExx xx             ldx WAVEPTR ; point to start of data for wave
  754  754   000391 180D 00xx           movb 0,X, CSEG ; get number of wave segments
             000395 xx         
  755  755   000396 1805 01xx           movw 1,X, VALUE ; get initial value for DAC
             00039A xx         
  756  756   00039B 180D 03xx           movb 3,X, LSEG ; load segment length
             00039F xx         
  757  757   0003A0 1805 04xx           movw 4,X, SEGINC ; load segment increment
             0003A4 xx         
  758  758   0003A5 08                  inx ; inc SEGPTR to next segment
  759  759   0003A6 08                  inx
  760  760   0003A7 08                  inx
  761  761   0003A8 08                  inx
  762  762   0003A9 08                  inx
  763  763   0003AA 08                  inx
  764  764   0003AB 7Exx xx             stx SEGPTR ; store incremented SEGPTR for next segment
  765  765                              ;movb #$01, DPRMPT ; set flag for display of NINT prompt
  766  766   0003AE 180B 03xx           movb #$03, t5state ; set next state
             0003B2 xx         
  767  767   0003B3 3D                  t5s2a: rts
  768  768                      
  769  769                              
  770  770                              
  771  771                      ;________________________________________________________________________________________
  772  772                      
  773  773                      t5s3:  ;wait for NINT        
  774  774                              
  775  775                           ;set run if correct nint
  776  776                           ;needs more stuff 
  777  777                           
  778  778   0003B4 F7xx xx             tst NINTOK
  779  779   0003B7 2754                beq exit5 
  780  780   0003B9 180B 01xx           movb #$01, RUN 
             0003BD xx         
  781  781   0003BE 180B 04xx           movb #$04, t5state 
             0003C2 xx         
  782  782   0003C3 3D                  rts 
  783  783                               
  784  784                      ;________________________________________________________________________________________
  785  785                      
  786  786                      t5s4:  ;Display wave  
  787  787                              ;bgnd

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  788  788   0003C4 F7xx xx             tst RUN
  789  789   0003C7 273B                beq t5s4c         ; do not update function generator if RUN=0
  790  790   0003C9 F7xx xx             tst NEWBTI
  791  791   0003CC 273E                beq t5s4e         ; do not update function generator if NEWBTI=0
  792  792   0003CE 73xx xx             dec LSEG          ; decrement segment length counter
  793  793   0003D1 2626                bne t5s4b         ; if not at end, simply update DAC output
  794  794   0003D3 73xx xx             dec CSEG          ; if at end, decrement segment counter
  795  795   0003D6 260E                bne t5s4a         ; if not last segment, skip reinit of wave
  796  796   0003D8 FExx xx             ldx WAVEPTR       ; point to start of data for wave
  797  797   0003DB 180D 00xx           movb 0,X, CSEG    ; get number of wave segments
             0003DF xx         
  798  798   0003E0 08                  inx               ; inc SEGPTR to start of first segment
  799  799   0003E1 08                  inx
  800  800   0003E2 08                  inx
  801  801   0003E3 7Exx xx             stx SEGPTR        ; store incremented SEGPTR
  802  802   0003E6 FExx xx             t5s4a: ldx SEGPTR ; point to start of new segment
  803  803   0003E9 180D 00xx           movb 0,X, LSEG    ; initialize segment length counter
             0003ED xx         
  804  804   0003EE 1805 01xx           movw 1,X, SEGINC  ; load segment increment
             0003F2 xx         
  805  805   0003F3 08                  inx               ; inc SEGPTR to next segment
  806  806   0003F4 08                  inx
  807  807   0003F5 08                  inx
  808  808   0003F6 7Exx xx             stx SEGPTR        ; store incremented SEGPTR
  809  809   0003F9 FCxx xx             t5s4b: ldd VALUE  ; get current DAC input value
  810  810   0003FC F3xx xx             addd SEGINC       ; add SEGINC to current DAC input value
  811  811   0003FF 7Cxx xx             std VALUE         ; store incremented DAC input value
  812  812   000402 2005                bra t5s4d
  813  813   000404 180B 01xx           t5s4c: movb #$01, t5state ; set next state
             000408 xx         
  814  814   000409 79xx xx             t5s4d: clr NEWBTI
  815  815   00040C 3D                  t5s4e: rts
  816  816                       
  817  817                       exit5: 
  818  818                       
  819  819   00040D 3D                  rts 
  820  820                      
  821  821                      ;/------------------------------------------------------------------------------------\
  822  822                      ;| Subroutines                                                                        |
  823  823                      ;\------------------------------------------------------------------------------------/
  824  824                      ; General purpose subroutines go here
  825  825                      
  826  826                      ;------ISUBROUT-----------------------------------------------------------------------;
  827  827                      
  828  828                      isubrout:
  829  829                      
  830  830                      ;first check run is one 
  831  831                             ;bgnd
  832  832   00040E F7xx xx            tst RUN 
  833  833   000411 271D               beq NXT_INT
  834  834                      
  835  835                      ;next check if CINT is zero 
  836  836                              
  837  837   000413 18F7 xxxx          tstw CINT 
  838  838   000417 2706               beq NEW_CINT 
  839  839   000419 1873 xxxx          decw CINT  
  840  840   00041D 2011               bra NXT_INT 
  841  841                              
  842  842                      NEW_CINT: 
  843  843                      
  844  844   00041F FCxx xx            ldd NINT 
  845  845   000422 7Cxx xx            std CINT 
  846  846   000425 180B 01xx          movb #$01, NEWBTI 
             000429 xx         

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  847  847   00042A FCxx xx            ldd VALUE 
  848  848   00042D 16xx xx            jsr OUTDACA 
  849  849                             
  850  850                      NXT_INT:
  851  851                              
  852  852   000430 DC50                ldd TC0                ; read current timer count  
  853  853   000432 F3xx xx             addd INTERVAL          ; add interval 
  854  854   000435 5C50                std TC0                ; store result  
  855  855   000437 4C4E 01             bset TFLG1, $01        ; clear timer channel 0 flag by writing a 1 to it
  856  856                             
  857  857                              
  858  858   00043A 0B                  rti
  859  859                      
  860  860                      ;------BACKSPACE----------------------------------------------------------------------;   
  861  861                               
  862  862                      backspace:
  863  863                        
  864  864   00043B F7xx xx             tst COUNT                     ;test if count is zero
  865  865   00043E 2717                beq bkspexit                  ;if the count is zero, dont allow backspace to occur 
  866  866   000440 16xx xx             jsr GETADDR                   ;get current position of LCR
  867  867   000443 43                  deca                          ;decrement one
  868  868   000444 16xx xx             jsr SETADDR                   ;set address to new position
  869  869   000447 CExx xx             ldx #BACKSPACE                ;load a blank space 
  870  870   00044A 16xx xx             jsr OUTSTRING                 ;output a blank space
  871  871   00044D 16xx xx             jsr GETADDR                   ;get current position of LCR
  872  872   000450 43                  deca                          ;decrement one
  873  873   000451 16xx xx             jsr SETADDR                   ;set address to new position
  874  874   000454 73xx xx             dec COUNT                     ;reset the value of count
  875  875                        
  876  876                      bkspexit:
  877  877                      
  878  878   000457 3D                 rts
  879  879                             
  880  880                      ;------CONVERSION---------------------------------------------------------------------------;
  881  881                      
  882  882                      conversion:
  883  883                      		
  884  884                      ;clear all variables 
  885  885                      
  886  886   000458 1879 xxxx   	    	clrw RESULT
  887  887   00045C 79xx xx     	    	clr TMP
  888  888   00045F 79xx xx     	     	clr ERR
  889  889   000462 CExx xx     	    	ldx #BUFFER
  890  890                      	    	
  891  891                      ;pushes registers to stack so that they remain unchanged by the subroutine 
  892  892                      	  
  893  893   000465 35            	   	pshy		
  894  894   000466 37            	  	pshb
  895  895   000467 39            	  	pshc
  896  896                      		
  897  897                      		
  898  898                      convloop:
  899  899                      
  900  900                      	
  901  901   000468 B6xx xx     	    	ldaa COUNT		;check if COUNT has finished for loop
  902  902   00046B 272A        	    	beq loopfin		;branch to exit if COUNT is done
  903  903                      		
  904  904                      		
  905  905   00046D FDxx xx     	     	ldy RESULT		;load current value of RESULT into register y for use
  906  906   000470 CC00 0A     	    	ldd #$000A		;load hex 10 into accumulator for use
  907  907   000473 13              		emul			    ;multiply register y and acc d
  908  908   000474 7Cxx xx     	    	std RESULT		;keep the bottom 2 bytes of the emul since we are never dealing with 4 bit nums
  909  909                      		
  910  910                      		

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  911  911                      		
  912  912   000477 B6xx xx     	    	ldaa TMP	  	;TMP is used for index addressing
  913  913   00047A E6E4        	    	ldab a,x	  	;reference the correct digit in the BUFFER using TMP
  914  914   00047C C030        	    	subb #$30	  	;subtract $30 to get the decimal value of the ascii code
  915  915                      	    	
  916  916                      		
  917  917   00047E 87          	    	clra
  918  918   00047F F3xx xx     	    	addd RESULT		;add RESULT and acc d 
  919  919   000482 97          	    	tsta          ;test if a is zero 
  920  920   000483 260B        	    	bne ERR1      ;if it is not zero, it has "overflowed"
  921  921   000485 7Cxx xx     	    	std RESULT		;store addition in RESULT
  922  922   000488 72xx xx     	    	inc TMP		  	;inc TMP so that BUFFER digits are correctly referenced
  923  923   00048B 73xx xx     	    	dec COUNT		  ;dec COUNT to track how long the loop has operated for
  924  924   00048E 20D8        	    	bra convloop
  925  925                      			
  926  926                      
  927  927                      ERR1:		
  928  928                      
  929  929   000490 180B 01xx   	    	movb #$01, ERR ;set ERR for MAGNITUDE TOO LARGE
             000494 xx         
  930  930   000495 200A            		bra cnvexit
  931  931                      	
  932  932                      loopfin:
  933  933                      		
  934  934   000497 FExx xx     	    	ldx RESULT     ;load x with result 
  935  935   00049A 2605        	    	bne cnvexit	   ;if the result is zero, fall through and set error state
  936  936                      		
  937  937                      ERR2:
  938  938                      
  939  939   00049C 180B 02xx   	    	movb #$02, ERR  ;set ERR for ZERO MAGNITUDE INAPPROPRIATE
             0004A0 xx         
  940  940                      
  941  941                      cnvexit:
  942  942                      
  943  943   0004A1 B6xx xx     	    	ldaa ERR		;load ERRor into accumulator a
  944  944                      	    	
  945  945                      ;pulls registers from stack to restore them to pre-subroutine states
  946  946                      
  947  947   0004A4 38          	    	pulc        
  948  948   0004A5 33          	    	pulb
  949  949   0004A6 31              		puly
  950  950   0004A7 3D              		rts         ;return
  951  951                                     
  952  952                      ;-------------------Cooperative Fixed Messaging-------------------------------------------;        
  953  953                      
  954  954                      PUTCHAR1:
  955  955                          
  956  956   0004A8 7Exx xx             stx DPTR                      ;store the contents of x into DPTR 
  957  957   0004AB 16xx xx             jsr SETADDR                   ;set the address on the LCD 
  958  958   0004AE 79xx xx             clr FIRSTCH                   ;clear first char  
  959  959   0004B1 1804 xxxx           movw TICKS_ERR, COUNT_ERR     ;initialize the amount of ticks an error will disply for
             0004B5 xxxx       
  960  960                                
  961  961                      PUTCHAR:  
  962  962                              
  963  963   0004B7 FExx xx             ldx DPTR                      ;put whats in DPTR into x 
  964  964   0004BA E600                ldab 0,x                      ;input the current char to be displayed in b 
  965  965   0004BC 2716                beq ERR_DELAY 
  966  966   0004BE 1872 xxxx           incw DPTR                     ;increment the position of DPTR to get next character 
  967  967   0004C2 16xx xx             jsr OUTCHAR                   ;output the current charater 
  968  968   0004C5 3D                  rts                           ;exit 
  969  969                              
  970  970                      mess_exit:
  971  971                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  972  972   0004C6 180B 01xx           movb #$01, t4state
             0004CA xx         
  973  973   0004CB 180B 01xx           movb #$01, MSG_NUM
             0004CF xx         
  974  974   0004D0 16xx xx             jsr clrcurs
  975  975   0004D3 3D                  rts
  976  976                              
  977  977                              
  978  978                      ERR_DELAY:
  979  979                             
  980  980   0004D4 16xx xx             jsr clrcurs
  981  981   0004D7 B6xx xx             ldaa t4state
  982  982   0004DA 8107                cmpa #$07
  983  983   0004DC 2FE8                ble mess_exit
  984  984                            
  985  985   0004DE F7xx xx             tst COUNT_ERR
  986  986   0004E1 2705                beq err_exit
  987  987   0004E3 1873 xxxx           decw COUNT_ERR
  988  988   0004E7 3D                  rts
  989  989                                  
  990  990                      err_exit:
  991  991                              
  992  992   0004E8 F6xx xx             ldab WAVE_NUM           ;load wave number into b
  993  993   0004EB CB03                addb #$03               ;add 3 to get the corresponding task 4 state
  994  994   0004ED 7Bxx xx             stab t4state            ;store message number in state
  995  995   0004F0 180B 01xx           movb #$01, FIRSTCH
             0004F4 xx         
  996  996   0004F5 3D                  rts
  997  997                                  
  998  998                      
  999  999                      clrcurs: ;resets the cursor address 
 1000 1000                      
 1001 1001   0004F6 36                  psha
 1002 1002   0004F7 8630                ldaa #$30
 1003 1003   0004F9 16xx xx             jsr SETADDR
 1004 1004   0004FC 32                  pula
 1005 1005   0004FD 3D                  rts
 1006 1006                              
 1007 1007                              
 1008 1008                      ;-----------------clearbuffer----------------------   
 1009 1009                      
 1010 1010                      clearbuffer:
 1011 1011                      
 1012 1012                      ;reset the buffer so it is full of zeros 
 1013 1013                      
 1014 1014   0004FE CExx xx             ldx #BUFFER
 1015 1015   000501 8600                ldaa #$00
 1016 1016   000503 69E4                clr a, x
 1017 1017   000505 42                  inca
 1018 1018   000506 69E4                clr a, x
 1019 1019   000508 42                  inca
 1020 1020   000509 69E4                clr a, x
 1021 1021   00050B 3D                  rts
 1022 1022                             
 1023 1023                      
 1024 1024                      ;/------------------------------------------------------------------------------------\
 1025 1025                      ;| ASCII Messages and Constant Data                                                   |
 1026 1026                      ;\------------------------------------------------------------------------------------/
 1027 1027                      ; Any constants can be defined here
 1028 1028                      
 1029 1029   00050C 313A 2053   TOP:  		DC.B '1: SAW, 2: SINE-7, 3: SQUARE, 4: SINE-15', $00	;message for the top of the screen
             000510 4157 2C20  
             000514 323A 2053  
             000518 494E 452D  

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             00051C 372C 2033  
             000520 3A20 5351  
             000524 5541 5245  
             000528 2C20 343A  
             00052C 2053 494E  
             000530 452D 3135  
             000534 00         
 1030 1030                      
 1031 1031   000535 5341 5754   SAWMSG:  		DC.B 'SAWTOOTH WAVE        NINT:     [1-->255]', $00	;message for when SAWTOOTH is chosen
             000539 4F4F 5448  
             00053D 2057 4156  
             000541 4520 2020  
             000545 2020 2020  
             000549 204E 494E  
             00054D 543A 2020  
             000551 2020 205B  
             000555 312D 2D3E  
             000559 3235 355D  
             00055D 00         
 1032 1032                      
 1033 1033   00055E 372D 5345   SEG7MSG:	  	DC.B '7-SEGMENT SINE WAVE  NINT:     [1-->255]', $00	;message for when 7 Seg sine is chosen
             000562 474D 454E  
             000566 5420 5349  
             00056A 4E45 2057  
             00056E 4156 4520  
             000572 204E 494E  
             000576 543A 2020  
             00057A 2020 205B  
             00057E 312D 2D3E  
             000582 3235 355D  
             000586 00         
 1034 1034                      
 1035 1035   000587 5351 5541   SQUAREMSG:		DC.B 'SQUARE WAVE          NINT:     [1-->255]', $00	;message for when SQUARE is chosen
             00058B 5245 2057  
             00058F 4156 4520  
             000593 2020 2020  
             000597 2020 2020  
             00059B 204E 494E  
             00059F 543A 2020  
             0005A3 2020 205B  
             0005A7 312D 2D3E  
             0005AB 3235 355D  
             0005AF 00         
 1036 1036                      
 1037 1037   0005B0 3135 2D53   SEG15MSG:		DC.B '15-SEGMENT SINE WAVE NINT:     [1-->255]', $00	;message for when 15 seg sine is chosen
             0005B4 4547 4D45  
             0005B8 4E54 2053  
             0005BC 494E 4520  
             0005C0 5741 5645  
             0005C4 204E 494E  
             0005C8 543A 2020  
             0005CC 2020 205B  
             0005D0 312D 2D3E  
             0005D4 3235 355D  
             0005D8 00         
 1038 1038                      
 1039 1039   0005D9 2000        BACKSPACE: DC.B ' ' , $00 
 1040 1040                      
 1041 1041   0005DB 4D41 474E   E1:	DC.B 'MAGNITUDE TOO LARGE', $00	;message for when MAGNITUDE TOO LARGE
             0005DF 4954 5544  
             0005E3 4520 544F  
             0005E7 4F20 4C41  
             0005EB 5247 4500  
 1042 1042   0005EF 494E 5641   E2:	DC.B 'INVALID MAGNITUDE  ', $00	;message for when INVALID MAGNITUDE  

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             0005F3 4C49 4420  
             0005F7 4D41 474E  
             0005FB 4954 5544  
             0005FF 4520 2000  
 1043 1043   000603 4E4F 2044   E3:	DC.B 'NO DIGITS ENTERED  ', $00	;message for when NO DIGITS ENTERED    
             000607 4947 4954  
             00060B 5320 454E  
             00060F 5445 5245  
             000613 4420 2000  
 1044 1044                      
 1045 1045   000617 02          SAWTOOTH:	DC.B 2 		; number of segments for SAWTOOTH
 1046 1046   000618 0CCC              		DC.W 3276	 	; initial DAC input value
 1047 1047   00061A 01                		DC.B 1	 	; length for segment_1
 1048 1048   00061B 0CCC              		DC.W 3276 	; increment for segment_1
 1049 1049   00061D 09                		DC.B 9	 	; length for segment_2
 1050 1050   00061E FE94              		DC.W -364 	; increment for segment_2
 1051 1051                      		
 1052 1052   000620 07          SINE_7:   DC.B 7		; number of segments for SINE_7
 1053 1053   000621 0800              		DC.W 2048	; initial DAC input value
 1054 1054   000623 19                		DC.B 25		; length for segment_1
 1055 1055   000624 0021              		DC.W 33		; increment for segment_1
 1056 1056   000626 32                		DC.B 50		; length for segment_2
 1057 1057   000627 0008              		DC.W 8		; increment for segment_2
 1058 1058   000629 32                		DC.B 50		; length for segment_3
 1059 1059   00062A FFF8              		DC.W -8		; increment for segment_3
 1060 1060   00062C 32                		DC.B 50		; length for segment_4
 1061 1061   00062D FFDF              		DC.W -33	; increment for segment_4
 1062 1062   00062F 32                		DC.B 50		; length for segment_5
 1063 1063   000630 FFF8              		DC.W -8		; increment for segment_5
 1064 1064   000632 32                		DC.B 50		; length for segment_6
 1065 1065   000633 0008              		DC.W 8		; increment for segment_6
 1066 1066   000635 19                		DC.B 25		; length for segment_7
 1067 1067   000636 0021              		DC.W 33		; increment for segment_7
 1068 1068                        		
 1069 1069   000638 04          SQUARE:	  DC.B 4 		; number of segments for SQUARE
 1070 1070   000639 0000              		DC.W 0	 	; initial DAC input value
 1071 1071   00063B 09                		DC.B 9	 	; length for segment_1
 1072 1072   00063C 0000              		DC.W 0 		; increment for segment_1
 1073 1073   00063E 01                		DC.B 1	 	; length for segment_2
 1074 1074   00063F 0CC4              		DC.W 3268 ; increment for segment_2
 1075 1075   000641 09                		DC.B 9	 	; length for segment_3
 1076 1076   000642 0000              		DC.W 0	 	; increment for segment_3
 1077 1077   000644 01                		DC.B 1	 	; length for segment_4
 1078 1078   000645 F33C              		DC.W -3268 	; increment for segment_4
 1079 1079                      		
 1080 1080   000647 0F          SINE_15:	DC.B 15 	; number of segments for SINE
 1081 1081   000648 0800              		DC.W 2048 ; initial DAC input value
 1082 1082   00064A 0A                		DC.B 10		; length for segment_1
 1083 1083   00064B 0029              		DC.W 41 	; increment for segment_1
 1084 1084   00064D 15                		DC.B 21 	; length for segment_2
 1085 1085   00064E 0025              		DC.W 37 	; increment for segment_2
 1086 1086   000650 15                		DC.B 21 	; length for segment_3
 1087 1087   000651 0019              		DC.W 25 	; increment for segment_3
 1088 1088   000653 15                		DC.B 21 	; length for segment_4
 1089 1089   000654 0009              		DC.W 9 		; increment for segment_4
 1090 1090   000656 15                		DC.B 21 	; length for segment_5
 1091 1091   000657 FFF7              		DC.W -9 	; increment for segment_5
 1092 1092   000659 15                		DC.B 21 	; length for segment_6
 1093 1093   00065A FFE7              		DC.W -25 	; increment for segment_6
 1094 1094   00065C 15                		DC.B 21 	; length for segment_7
 1095 1095   00065D FFDB              		DC.W -37 	; increment for segment_7
 1096 1096   00065F 14                		DC.B 20 	; length for segment_8
 1097 1097   000660 FFD7              		DC.W -41 	; increment for segment_8
 1098 1098   000662 15                		DC.B 21 	; length for segment_9

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1099 1099   000663 FFDB              		DC.W -37 	; increment for segment_9
 1100 1100   000665 15                		DC.B 21 	; length for segment_10
 1101 1101   000666 FFE7              		DC.W -25 	; increment for segment_10
 1102 1102   000668 15                		DC.B 21 	; length for segment_11
 1103 1103   000669 FFF7              		DC.W -9 	; increment for segment_11
 1104 1104   00066B 15                		DC.B 21 	; length for segment_12
 1105 1105   00066C 0009              		DC.W 9 		; increment for segment_12
 1106 1106   00066E 15                		DC.B 21 	; length for segment_13
 1107 1107   00066F 0019              		DC.W 25 	; increment for segment_13
 1108 1108   000671 15                		DC.B 21 	; length for segment_14
 1109 1109   000672 0025              		DC.W 37 	; increment for segment_14
 1110 1110   000674 0A                		DC.B 10 	; length for segment_15
 1111 1111   000675 0029              		DC.W 41 	; increment for segment_15
 1112 1112                      
 1113 1113                      ;/------------------------------------------------------------------------------------\
 1114 1114                      ;| Vectors                                                                            |
 1115 1115                      ;\------------------------------------------------------------------------------------/
 1116 1116                      ; Add interrupt and reset vectors here
 1117 1117                      
 1118 1118                              ORG   $FFFE                    ; reset vector address
 1119 1119  a00FFFE xxxx                DC.W  Entry
 1120 1120                      
 1121 1121                              ORG   $FFEE                    ; chan 0 vector address 
 1122 1122  a00FFEE xxxx                DC.W  isubrout 
